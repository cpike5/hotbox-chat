@page "/channels/{Id:guid}"
@using HotBox.Client.Models
@using HotBox.Client.State
@using HotBox.Client.Services
@inject ChannelState ChannelState
@inject ApiClient Api
@inject ChatHubService ChatHub
@inject UnreadStateService UnreadState
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>HotBox - @(ChannelState.ActiveChannel?.Name ?? "Channel")</PageTitle>

<MessageList OnScrollNearTop="LoadOlderMessages" />
<MessageInput />

@code {
    [Parameter]
    public Guid Id { get; set; }

    [SupplyParameterFromQuery]
    public Guid? MessageId { get; set; }

    private Guid _currentChannelId;
    private Guid? _pendingJumpToMessage;
    private double _previousScrollHeight;
    private bool _pendingScrollRestore;
    private readonly Dictionary<Guid, Timer> _typingExpiryTimers = new();

    protected override void OnInitialized()
    {
        // Subscribe to real-time channel events
        ChatHub.OnMessageReceived += HandleMessageReceived;
        ChatHub.OnUserTyping += HandleUserTyping;
        ChatHub.OnUserStoppedTyping += HandleUserStoppedTyping;
        ChatHub.OnConnectionChanged += HandleConnectionChanged;
    }

    protected override async Task OnParametersSetAsync()
    {
        // If same channel but different message target, reload messages around that message
        if (_currentChannelId == Id && MessageId.HasValue)
        {
            _pendingJumpToMessage = MessageId.Value;
            ChannelState.SetLoadingMessages(true);
            try
            {
                var messages = await Api.GetMessagesAsync(Id, around: MessageId.Value);
                ChannelState.SetMessages(messages);
                ChannelState.SetHasMoreMessages(true);
            }
            finally
            {
                ChannelState.SetLoadingMessages(false);
            }
            return;
        }

        // Avoid reloading if navigating to the same channel
        if (_currentChannelId == Id)
            return;

        _currentChannelId = Id;

        // Set active channel from the already-loaded channel list
        var channel = ChannelState.Channels.FirstOrDefault(c => c.Id == Id);
        if (channel is not null)
        {
            ChannelState.SetActiveChannel(channel);
        }
        else
        {
            // Channel not in local state; fetch it directly
            var fetched = await Api.GetChannelAsync(Id);
            if (fetched is not null)
            {
                ChannelState.SetActiveChannel(fetched);
            }
        }

        // Load messages for this channel
        ChannelState.SetLoadingMessages(true);
        ChannelState.SetHasMoreMessages(true);
        try
        {
            List<MessageResponse> messages;
            if (MessageId.HasValue)
            {
                messages = await Api.GetMessagesAsync(Id, around: MessageId.Value);
                _pendingJumpToMessage = MessageId.Value;
            }
            else
            {
                messages = await Api.GetMessagesAsync(Id);
            }
            ChannelState.SetMessages(messages);

            // If we got less than the default limit (50), we've loaded all messages
            if (messages.Count < 50)
            {
                ChannelState.SetHasMoreMessages(false);
            }
        }
        finally
        {
            ChannelState.SetLoadingMessages(false);
        }

        // Join the SignalR channel group if connected
        if (ChatHub.IsConnected)
        {
            await ChatHub.JoinChannelAsync(Id);
        }

        // Mark channel as read
        await UnreadState.MarkChannelAsReadAsync(Id);
    }

    private void HandleMessageReceived(MessageResponse message)
    {
        if (message.ChannelId == _currentChannelId)
        {
            // Clear typing indicator for the author who just sent a message
            ChannelState.RemoveTypingUser(message.AuthorId);
            ChannelState.AddMessage(message);

            // Purge oldest messages if beyond window (user is near bottom receiving new messages)
            if (ChannelState.Messages.Count > ChannelState.MessageWindowSize)
            {
                ChannelState.PurgeOldMessages(ChannelState.MessageWindowSize);
            }

            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleUserTyping(Guid channelId, Guid userId, string displayName)
    {
        if (channelId == _currentChannelId)
        {
            ChannelState.AddTypingUser(userId, displayName);
            InvokeAsync(StateHasChanged);

            // Start or reset a 5s expiry timer for this user
            if (_typingExpiryTimers.TryGetValue(userId, out var existing))
            {
                existing.Change(5000, Timeout.Infinite);
            }
            else
            {
                var timer = new Timer(_ =>
                {
                    ChannelState.RemoveTypingUser(userId);
                    InvokeAsync(StateHasChanged);
                    _typingExpiryTimers.Remove(userId);
                }, null, 5000, Timeout.Infinite);
                _typingExpiryTimers[userId] = timer;
            }
        }
    }

    private async void HandleConnectionChanged(bool connected)
    {
        // Re-join the channel group after SignalR reconnects (new ConnectionId loses group memberships)
        if (connected && _currentChannelId != Guid.Empty)
        {
            try
            {
                await ChatHub.JoinChannelAsync(_currentChannelId);
            }
            catch (Exception)
            {
                // Connection may have dropped again before we could join
            }
        }
    }

    private void HandleUserStoppedTyping(Guid channelId, Guid userId)
    {
        if (channelId == _currentChannelId)
        {
            ChannelState.RemoveTypingUser(userId);
            InvokeAsync(StateHasChanged);

            // Cancel and remove the expiry timer
            if (_typingExpiryTimers.Remove(userId, out var timer))
            {
                timer.Dispose();
            }
        }
    }

    private async Task LoadOlderMessages()
    {
        // Guard: don't load if already loading, no more messages, or no messages yet
        if (ChannelState.IsLoadingOlderMessages || !ChannelState.HasMoreMessages || ChannelState.Messages.Count == 0)
            return;

        ChannelState.SetLoadingOlderMessages(true);
        try
        {
            // Get the oldest message timestamp
            var oldestMessage = ChannelState.Messages[0];
            var before = oldestMessage.CreatedAtUtc;

            // Save scroll position before prepending
            var scrollInfo = await JS.InvokeAsync<ScrollPosition>("chatInterop.getScrollPosition", ".messages-area");
            _previousScrollHeight = scrollInfo.ScrollHeight;

            // Fetch older messages
            var olderMessages = await Api.GetMessagesAsync(_currentChannelId, before: before, limit: 50);

            if (olderMessages.Count > 0)
            {
                // Prepend messages to state
                ChannelState.PrependMessages(olderMessages);

                // If we got less than requested, we've reached the beginning
                if (olderMessages.Count < 50)
                {
                    ChannelState.SetHasMoreMessages(false);
                }

                // Schedule scroll position restoration for next render
                _pendingScrollRestore = true;
                StateHasChanged();

                // User is scrolled up (loaded older messages) â€” purge newest messages from end if beyond window
                if (ChannelState.Messages.Count > ChannelState.MessageWindowSize)
                {
                    ChannelState.PurgeNewMessages(ChannelState.MessageWindowSize);
                }
            }
            else
            {
                ChannelState.SetHasMoreMessages(false);
            }
        }
        finally
        {
            ChannelState.SetLoadingOlderMessages(false);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingJumpToMessage.HasValue)
        {
            var targetId = _pendingJumpToMessage.Value;
            _pendingJumpToMessage = null;
            await JS.InvokeVoidAsync("chatInterop.scrollToElement", $"msg-{targetId}");
        }
        else if (_pendingScrollRestore)
        {
            _pendingScrollRestore = false;

            // Restore scroll position after prepend
            var newScrollInfo = await JS.InvokeAsync<ScrollPosition>("chatInterop.getScrollPosition", ".messages-area");
            var scrollDelta = newScrollInfo.ScrollHeight - _previousScrollHeight;
            var newScrollTop = newScrollInfo.ScrollTop + scrollDelta;

            await JS.InvokeVoidAsync("chatInterop.setScrollTop", ".messages-area", newScrollTop);
        }
    }

    private record ScrollPosition(double ScrollTop, double ScrollHeight, double ClientHeight);

    public void Dispose()
    {
        // Unsubscribe from real-time events
        ChatHub.OnMessageReceived -= HandleMessageReceived;
        ChatHub.OnUserTyping -= HandleUserTyping;
        ChatHub.OnUserStoppedTyping -= HandleUserStoppedTyping;
        ChatHub.OnConnectionChanged -= HandleConnectionChanged;

        // Dispose all typing expiry timers
        foreach (var timer in _typingExpiryTimers.Values)
        {
            timer.Dispose();
        }
        _typingExpiryTimers.Clear();

        // Leave the SignalR channel group when navigating away
        if (ChatHub.IsConnected && _currentChannelId != Guid.Empty)
        {
            _ = ChatHub.LeaveChannelAsync(_currentChannelId);
        }
    }
}
