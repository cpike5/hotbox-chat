@page "/dm/{UserId:guid}"
@using HotBox.Client.State
@using HotBox.Client.Services
@using HotBox.Client.Models
@inject DirectMessageState DirectMessageState
@inject AuthState AuthState
@inject ApiClient Api
@inject ChatHubService ChatHub
@inject UnreadStateService UnreadState
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>HotBox - DM with @(DirectMessageState.ActiveConversationDisplayName ?? "User")</PageTitle>

<DirectMessageMessageList OnScrollNearTop="LoadOlderMessages" />
<DirectMessageInput />

@code {
    [Parameter]
    public Guid UserId { get; set; }

    [SupplyParameterFromQuery]
    public Guid? MessageId { get; set; }

    private Guid _currentUserId;
    private Guid? _pendingJumpToMessage;
    private double _previousScrollHeight;
    private bool _pendingScrollRestore;
    private readonly Dictionary<Guid, Timer> _typingExpiryTimers = new();

    protected override void OnInitialized()
    {
        // Set the current user ID on state so AddMessage can determine the "other user"
        if (AuthState.CurrentUser is not null)
        {
            DirectMessageState.SetCurrentUserId(AuthState.CurrentUser.Id);
        }

        // Subscribe to real-time DM events
        ChatHub.OnDirectMessageReceived += HandleDirectMessageReceived;
        ChatHub.OnDirectMessageTyping += HandleDirectMessageTyping;
        ChatHub.OnDirectMessageStoppedTyping += HandleDirectMessageStoppedTyping;
    }

    protected override async Task OnParametersSetAsync()
    {
        // If same conversation but different message target, just set the jump target
        if (_currentUserId == UserId && MessageId.HasValue)
        {
            _pendingJumpToMessage = MessageId.Value;
            StateHasChanged();
            return;
        }

        // Avoid reloading if navigating to the same conversation
        if (_currentUserId == UserId)
            return;

        _currentUserId = UserId;

        // Set active conversation from the already-loaded conversations list
        var conversation = DirectMessageState.Conversations.FirstOrDefault(c => c.UserId == UserId);
        if (conversation is not null)
        {
            DirectMessageState.SetActiveConversation(conversation.UserId, conversation.DisplayName);
        }
        else
        {
            // Conversation not in local state; set with userId and a placeholder name
            DirectMessageState.SetActiveConversation(UserId, "User");
        }

        // Load messages for this conversation
        DirectMessageState.SetLoadingMessages(true);
        DirectMessageState.SetHasMoreMessages(true);
        try
        {
            var messages = await Api.GetDirectMessagesAsync(UserId);
            DirectMessageState.SetMessages(messages);

            // If we got less than the default limit (50), we've loaded all messages
            if (messages.Count < 50)
            {
                DirectMessageState.SetHasMoreMessages(false);
            }

            // If we navigated here with a messageId, scroll to it after render
            if (MessageId.HasValue)
            {
                _pendingJumpToMessage = MessageId.Value;
            }
        }
        finally
        {
            DirectMessageState.SetLoadingMessages(false);
        }

        // Mark DM conversation as read
        await UnreadState.MarkDmAsReadAsync(UserId);
    }

    private void HandleDirectMessageReceived(DirectMessageResponse message)
    {
        // Only add to state if this message belongs to the active conversation
        if (DirectMessageState.ActiveConversationUserId.HasValue &&
            (message.SenderId == DirectMessageState.ActiveConversationUserId.Value ||
             message.RecipientId == DirectMessageState.ActiveConversationUserId.Value))
        {
            DirectMessageState.AddMessage(message);

            // Purge oldest messages if beyond window (user is near bottom receiving new messages)
            if (DirectMessageState.Messages.Count > DirectMessageState.MessageWindowSize)
            {
                DirectMessageState.PurgeOldMessages(DirectMessageState.MessageWindowSize);
            }

            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleDirectMessageTyping(Guid senderId, string displayName)
    {
        if (DirectMessageState.ActiveConversationUserId.HasValue &&
            senderId == DirectMessageState.ActiveConversationUserId.Value)
        {
            DirectMessageState.AddTypingUser(senderId, displayName);
            InvokeAsync(StateHasChanged);

            // Start or reset a 5s expiry timer for this sender
            if (_typingExpiryTimers.TryGetValue(senderId, out var existing))
            {
                existing.Change(5000, Timeout.Infinite);
            }
            else
            {
                var timer = new Timer(_ =>
                {
                    DirectMessageState.RemoveTypingUser(senderId);
                    InvokeAsync(StateHasChanged);
                    _typingExpiryTimers.Remove(senderId);
                }, null, 5000, Timeout.Infinite);
                _typingExpiryTimers[senderId] = timer;
            }
        }
    }

    private void HandleDirectMessageStoppedTyping(Guid senderId)
    {
        if (DirectMessageState.ActiveConversationUserId.HasValue &&
            senderId == DirectMessageState.ActiveConversationUserId.Value)
        {
            DirectMessageState.RemoveTypingUser(senderId);
            InvokeAsync(StateHasChanged);

            // Cancel and remove the expiry timer
            if (_typingExpiryTimers.Remove(senderId, out var timer))
            {
                timer.Dispose();
            }
        }
    }

    private async Task LoadOlderMessages()
    {
        // Guard: don't load if already loading, no more messages, or no messages yet
        if (DirectMessageState.IsLoadingOlderMessages || !DirectMessageState.HasMoreMessages || DirectMessageState.Messages.Count == 0)
            return;

        DirectMessageState.SetLoadingOlderMessages(true);
        try
        {
            // Get the oldest message timestamp
            var oldestMessage = DirectMessageState.Messages[0];
            var before = oldestMessage.CreatedAtUtc;

            // Save scroll position before prepending
            var scrollInfo = await JS.InvokeAsync<ScrollPosition>("chatInterop.getScrollPosition", ".messages-area");
            _previousScrollHeight = scrollInfo.ScrollHeight;

            // Fetch older messages
            var olderMessages = await Api.GetDirectMessagesAsync(UserId, before: before, limit: 50);

            if (olderMessages.Count > 0)
            {
                // Prepend messages to state
                DirectMessageState.PrependMessages(olderMessages);

                // If we got less than requested, we've reached the beginning
                if (olderMessages.Count < 50)
                {
                    DirectMessageState.SetHasMoreMessages(false);
                }

                // Schedule scroll position restoration for next render
                _pendingScrollRestore = true;
                StateHasChanged();

                // User is scrolled up (loaded older messages) â€” purge newest messages from end if beyond window
                if (DirectMessageState.Messages.Count > DirectMessageState.MessageWindowSize)
                {
                    DirectMessageState.PurgeNewMessages(DirectMessageState.MessageWindowSize);
                }
            }
            else
            {
                DirectMessageState.SetHasMoreMessages(false);
            }
        }
        finally
        {
            DirectMessageState.SetLoadingOlderMessages(false);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingJumpToMessage.HasValue)
        {
            var targetId = _pendingJumpToMessage.Value;
            _pendingJumpToMessage = null;
            await JS.InvokeVoidAsync("chatInterop.scrollToElement", $"msg-{targetId}");
        }
        else if (_pendingScrollRestore)
        {
            _pendingScrollRestore = false;

            // Restore scroll position after prepend
            var newScrollInfo = await JS.InvokeAsync<ScrollPosition>("chatInterop.getScrollPosition", ".messages-area");
            var scrollDelta = newScrollInfo.ScrollHeight - _previousScrollHeight;
            var newScrollTop = newScrollInfo.ScrollTop + scrollDelta;

            await JS.InvokeVoidAsync("chatInterop.setScrollTop", ".messages-area", newScrollTop);
        }
    }

    private record ScrollPosition(double ScrollTop, double ScrollHeight, double ClientHeight);

    public void Dispose()
    {
        // Unsubscribe from real-time events
        ChatHub.OnDirectMessageReceived -= HandleDirectMessageReceived;
        ChatHub.OnDirectMessageTyping -= HandleDirectMessageTyping;
        ChatHub.OnDirectMessageStoppedTyping -= HandleDirectMessageStoppedTyping;

        // Dispose all typing expiry timers
        foreach (var timer in _typingExpiryTimers.Values)
        {
            timer.Dispose();
        }
        _typingExpiryTimers.Clear();

        // Clear active conversation when navigating away
        DirectMessageState.ClearActiveConversation();
    }
}
