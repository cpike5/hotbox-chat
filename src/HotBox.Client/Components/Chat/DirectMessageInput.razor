@using HotBox.Client.State
@using HotBox.Client.Services
@inject DirectMessageState DirectMessageState
@inject ChatHubService ChatHub
@inject PresenceState PresenceState
@implements IDisposable

<div class="message-input-wrapper">
    <div class="message-input" style="position: relative;">
        @if (_showAutocomplete && _autocompleteResults.Count > 0)
        {
            <div class="mention-autocomplete" id="mention-autocomplete" role="listbox" aria-label="User suggestions">
                @for (var i = 0; i < _autocompleteResults.Count; i++)
                {
                    var index = i;
                    var user = _autocompleteResults[i];
                    <div class="mention-autocomplete-item @(i == _selectedIndex ? "selected" : "")"
                         id="mention-option-@index"
                         role="option"
                         aria-selected="@(i == _selectedIndex ? "true" : "false")"
                         @onmousedown="() => SelectMention(index)"
                         @onmousedown:preventDefault>
                        <span class="mention-display-name">@user.DisplayName</span>
                        @if (user.IsAgent)
                        {
                            <span class="mention-badge">BOT</span>
                        }
                    </div>
                }
            </div>
        }
        <input type="text"
               @bind="_displayText"
               @bind:event="oninput"
               @bind:after="OnInput"
               @onkeydown="HandleKeyDown"
               @onkeydown:preventDefault="_preventKeyDefault"
               placeholder="@GetPlaceholder()"
               disabled="@(DirectMessageState.ActiveConversationUserId is null)"
               aria-autocomplete="list"
               aria-expanded="@_showAutocomplete"
               aria-controls="mention-autocomplete"
               aria-activedescendant="@(_showAutocomplete && _selectedIndex >= 0 ? $"mention-option-{_selectedIndex}" : null)" />
        <button @onclick="SendMessage"
                disabled="@(DirectMessageState.ActiveConversationUserId is null)"
                aria-label="Send message">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        </button>
    </div>
    @if (DirectMessageState.TypingDisplayNames.Count > 0)
    {
        <div class="typing-indicator">
            @FormatTypingText()
        </div>
    }
</div>

@code {
    private string _displayText = string.Empty;
    private List<MentionEntry> _mentions = new();
    private DateTime _lastTypingSignal = DateTime.MinValue;
    private static readonly TimeSpan TypingDebounceInterval = TimeSpan.FromSeconds(3);

    // Mention autocomplete state
    private bool _showAutocomplete;
    private string _autocompleteQuery = string.Empty;
    private int _mentionStartIndex;
    private List<UserPresenceInfo> _autocompleteResults = new();
    private int _selectedIndex;
    private bool _preventKeyDefault;

    private record MentionEntry(string DisplayName, Guid UserId);

    protected override void OnInitialized()
    {
        DirectMessageState.OnChange += StateHasChanged;
    }

    private string GetPlaceholder()
    {
        if (DirectMessageState.ActiveConversationUserId is null)
            return "Select a conversation to start chatting";

        return $"Message @{DirectMessageState.ActiveConversationDisplayName}";
    }

    private void OnInput()
    {
        PruneMentions();
        UpdateAutocomplete();
    }

    private void PruneMentions()
    {
        _mentions.RemoveAll(m => !_displayText.Contains($"@{m.DisplayName}", StringComparison.Ordinal));
    }

    private void UpdateAutocomplete()
    {
        var lastAtIndex = _displayText.LastIndexOf('@');

        if (lastAtIndex >= 0 && (lastAtIndex == 0 || char.IsWhiteSpace(_displayText[lastAtIndex - 1])))
        {
            var query = _displayText[(lastAtIndex + 1)..];

            if (!query.Contains(' '))
            {
                _mentionStartIndex = lastAtIndex;
                _autocompleteQuery = query;
                _autocompleteResults = PresenceState.GetAllUsers()
                    .Where(u => u.DisplayName.Contains(query, StringComparison.OrdinalIgnoreCase))
                    .Take(8)
                    .ToList();
                _showAutocomplete = _autocompleteResults.Count > 0;
                _selectedIndex = 0;
                return;
            }
        }

        CloseAutocomplete();
    }

    private async Task HandleKeyDown(Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e)
    {
        _preventKeyDefault = false;

        if (_showAutocomplete && _autocompleteResults.Count > 0)
        {
            switch (e.Key)
            {
                case "ArrowUp":
                    _selectedIndex = (_selectedIndex - 1 + _autocompleteResults.Count) % _autocompleteResults.Count;
                    _preventKeyDefault = true;
                    return;
                case "ArrowDown":
                    _selectedIndex = (_selectedIndex + 1) % _autocompleteResults.Count;
                    _preventKeyDefault = true;
                    return;
                case "Enter":
                case "Tab":
                    SelectMention(_selectedIndex);
                    _preventKeyDefault = true;
                    return;
                case "Escape":
                    CloseAutocomplete();
                    _preventKeyDefault = true;
                    return;
            }
        }

        if (e.Key == "Enter" && !e.ShiftKey)
        {
            _preventKeyDefault = true;
            await SendMessage();
            return;
        }

        // Debounced typing indicator
        await SendTypingSignalAsync();
    }

    private void SelectMention(int index)
    {
        if (index < 0 || index >= _autocompleteResults.Count)
            return;

        var user = _autocompleteResults[index];
        var displayMention = $"@{user.DisplayName} ";

        // Replace from the '@' to the end of the query with the display mention
        var endOfQuery = _mentionStartIndex + 1 + _autocompleteQuery.Length;
        _displayText = _displayText[.._mentionStartIndex] + displayMention + _displayText[endOfQuery..];

        _mentions.Add(new MentionEntry(user.DisplayName, user.UserId));

        CloseAutocomplete();
        StateHasChanged();
    }

    private void CloseAutocomplete()
    {
        _showAutocomplete = false;
        _autocompleteQuery = string.Empty;
        _autocompleteResults.Clear();
        _selectedIndex = 0;
    }

    private string BuildSubmissionText()
    {
        var text = _displayText;
        var replacements = new List<(int Index, string DisplayName, Guid UserId)>();

        foreach (var mention in _mentions)
        {
            var searchFrom = 0;
            var target = $"@{mention.DisplayName}";
            while (true)
            {
                var idx = text.IndexOf(target, searchFrom, StringComparison.Ordinal);
                if (idx < 0) break;
                if (!replacements.Any(r => r.Index == idx))
                {
                    replacements.Add((idx, mention.DisplayName, mention.UserId));
                    break;
                }
                searchFrom = idx + 1;
            }
        }

        foreach (var r in replacements.OrderByDescending(r => r.Index))
        {
            var displayMention = $"@{r.DisplayName}";
            var structuredMention = $"@[{r.DisplayName}]({r.UserId})";
            text = text[..r.Index] + structuredMention + text[(r.Index + displayMention.Length)..];
        }

        return text.Trim();
    }

    private async Task SendMessage()
    {
        var content = BuildSubmissionText();
        if (string.IsNullOrEmpty(content) || DirectMessageState.ActiveConversationUserId is null)
            return;

        var recipientId = DirectMessageState.ActiveConversationUserId.Value;
        _displayText = string.Empty;
        _mentions.Clear();

        if (ChatHub.IsConnected)
        {
            await ChatHub.SendDirectMessageAsync(recipientId, content);
            await ChatHub.DirectMessageStoppedTypingAsync(recipientId);
        }
    }

    private async Task SendTypingSignalAsync()
    {
        if (DirectMessageState.ActiveConversationUserId is null || !ChatHub.IsConnected)
            return;

        var now = DateTime.UtcNow;
        if ((now - _lastTypingSignal) < TypingDebounceInterval)
            return;

        _lastTypingSignal = now;
        await ChatHub.DirectMessageTypingAsync(DirectMessageState.ActiveConversationUserId.Value);
    }

    private string FormatTypingText()
    {
        var users = DirectMessageState.TypingDisplayNames.ToList();

        return users.Count switch
        {
            1 => $"{users[0]} is typing...",
            2 => $"{users[0]} and {users[1]} are typing...",
            3 => $"{users[0]}, {users[1]}, and {users[2]} are typing...",
            _ => "Several people are typing..."
        };
    }

    public void Dispose()
    {
        DirectMessageState.OnChange -= StateHasChanged;
    }
}
