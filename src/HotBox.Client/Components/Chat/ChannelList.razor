@using HotBox.Client.State
@using HotBox.Client.Models
@using HotBox.Client.Services
@using HotBox.Core.Enums
@inject ChannelState ChannelState
@inject UnreadStateService UnreadState
@inject NavigationManager Navigation
@implements IDisposable

@if (ChannelState.IsLoadingChannels)
{
    @for (var i = 0; i < 5; i++)
    {
        <div class="skeleton-channel">
            <div class="skeleton skeleton-channel-hash"></div>
            <div class="skeleton skeleton-channel-name" style="width: @(_skeletonWidths[i % _skeletonWidths.Length])px;"></div>
        </div>
    }
}
else
{
    @foreach (var channel in TextChannels)
    {
        var isActive = ChannelState.ActiveChannel?.Id == channel.Id;
        var unreadCount = UnreadState.GetChannelUnreadCount(channel.Id);
        <button class="channel-tab @(isActive ? "active" : "") @(unreadCount > 0 ? "has-unread" : "")"
                @onclick="() => SelectChannel(channel)">
            <span class="tab-hash">#</span>
            <span>@channel.Name</span>
            @if (unreadCount > 0)
            {
                <span class="unread-badge">@unreadCount</span>
            }
        </button>
    }
}

@code {
    private static readonly int[] _skeletonWidths = { 64, 48, 72, 56, 44 };

    private IEnumerable<ChannelResponse> TextChannels =>
        ChannelState.Channels
            .Where(c => c.Type == ChannelType.Text)
            .OrderBy(c => c.SortOrder);

    protected override void OnInitialized()
    {
        ChannelState.OnChange += StateHasChanged;
        UnreadState.OnChange += StateHasChanged;
    }

    private void SelectChannel(ChannelResponse channel)
    {
        ChannelState.SetActiveChannel(channel);
        Navigation.NavigateTo($"/channels/{channel.Id}");
    }

    public void Dispose()
    {
        ChannelState.OnChange -= StateHasChanged;
        UnreadState.OnChange -= StateHasChanged;
    }
}
